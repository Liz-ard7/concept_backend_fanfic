---
timestamp: 'Mon Oct 13 2025 13:54:22 GMT-0400 (Eastern Daylight Time)'
content_id: 221e880bdd0660454b14f26ca0181e39f1690eed9a05ed676f28ce790e485eed
---

# file: src/concepts/Categorizing/Categorizing.ts

```typescript
// file: src/Categorizing/CategorizingConcept.ts

import { Collection, Db } from "npm:mongodb";
import { ID, Empty } from "@utils/types.ts";
import { GeminiLLM } from "../../../gemini-llm.ts"; // Assuming gemini-llm.ts is in the parent directory
import * as fs from 'fs';
import * as path from 'path';

// Declare collection prefix, use concept name
const PREFIX = "Categorizing" + ".";

// Generic types of this concept
type Fic = ID;

/**
 * Interface for the LLM's expected JSON output.
 * This combines the results of keywordGenerator and tagCleaner.
 */
interface LLMOutput {
  suggestedTags: string[];
  tagsToRemove: string[];
}

/**
 * @state
 * Data model for FicCategories stored in MongoDB.
 *
 * a set of FicCategories with
 *   an Fic
 *   a suggestedTags Category
 *   a tagsToRemove Category
 *
 * A 'Category' in this context is interpreted as a 'string[]' (an array of strings).
 */
interface FicCategoryDoc {
  _id: Fic; // The identifier for the fic being categorized
  suggestedTags: string[]; // Maps to 'a suggestedTags Category'
  tagsToRemove: string[]; // Maps to 'a tagsToRemove Category'
}

/**
 * @concept Categorizing [Fic]
 * @purpose to categorize a text into specific categories (i.e. a story will be categorized into a set of tags).
 *          "Categorizing" can also *remove* tags provided by the author if deemed necessary.
 * @principle A user submits their story and the tags the author has already added to the story.
 *            It outputs a list of suggested tags (properly categorized) to add to the story
 *            and tells the user if any of their author tags should be removed.
 */
export default class CategorizingConcept {
  ficCategories: Collection<FicCategoryDoc>;
  private llm: GeminiLLM;

  constructor(private readonly db: Db, llmConfig: { apiKey: string }) {
    this.ficCategories = this.db.collection(PREFIX + "ficCategories");
    this.llm = new GeminiLLM(llmConfig);
  }

  /**
   * Helper to provide context about the `tagsEdited2021.csv` file to the LLM.
   * As per the problem description, the LLM is expected to be "trained" or
   * informed about these tags. For this implementation, we provide a textual
   * reference in the prompt, assuming the LLM's general knowledge of AO3 tags
   * combined with this hint is sufficient. In a full system, the CSV content
   * might be loaded and injected directly or used for post-processing.
   * Lizzy edit: Yup this has been edited so that it is injected directly.
   */
  private getTagsCsvContext(): string {
    const csvFilePath = '../../../tagsEdited2021.csv';

    let csvString = 'Meow';
    try {
        csvString = this.readCsvFileAsString(csvFilePath);
    } catch (_error) {
        throw new Error("I can't parse tagsEdited2021");
    }
    return csvString;
  }

  /**
   * @action processCategorization
   * @purpose Combines the functionality of keywordGenerator and tagCleaner.
   *          It uses an LLM to generate suggested tags and identify author tags to be removed for a given fic.
   *
   * @requires fic: ID of the fic.
   * @requires ficText: The complete textual content of the fic.
   * @requires authorTags: A list of tags initially provided by the author of the fic.
   *
   * @effects Using an LLM, examines the ficText.
   *          Associates the top 20 most relevant tags (excluding those already in authorTags)
   *          to the content in a `suggestedTags` Category.
   *          Identifies authorTags that seem inappropriate for the fic, adding them to a `tagsToRemove` Category.
   *          If no FicCategory is associated with the fic, a new one is created.
   *          If one exists, it is updated with the new `suggestedTags` and `tagsToRemove`.
   *          Finally, it returns the `suggestedTags` and `tagsToRemove`.
   *
   * @param {object} args
   * @param {Fic} args.fic - The ID of the fanfiction to categorize.
   * @param {string} args.ficText - The full text content of the fanfiction.
   * @param {string[]} args.authorTags - An array of tags provided by the author.
   * @returns {Promise<{suggestedTags: string[], tagsToRemove: string[]} | {error: string}>}
   *          Returns the processed suggested tags and tags to remove, or an error object.
   */
  async processCategorization(
    { fic, ficText, authorTags }: { fic: Fic; ficText: string; authorTags: string[] },
  ): Promise<{ suggestedTags: string[]; tagsToRemove: string[] } | { error: string }> {
    // Precondition: `ficText` should not be empty to make a meaningful LLM call.
    if (!ficText || ficText.trim() === "") {
      return { error: "ficText cannot be empty for categorization." };
    }

    const tagsContext = this.getTagsCsvContext();
    const prompt = `
      You are an expert fanfiction tagger for ArchiveOfOurOwn (AO3).
      Your primary task is to carefully analyze the provided story text and its author-provided tags.
      You must produce a JSON object containing two distinct lists:

      1.  "suggestedTags": This list should contain up to 20 highly relevant tags that
          would be beneficial to add to the story. Crucially, these tags must NOT
          already be present in the "Author Tags" list provided below.
          Base your suggestions on common AO3 tagging practices and the story's content.
          Here is a list of the top tags with over 100 uses on AO3, sorted
          in order of greatest usage -> least usage: ${tagsContext}

      2.  "tagsToRemove": This list should identify any tags from the "Author Tags"
          list that appear inappropriate, misleading, or entirely irrelevant given
          the story's actual content.

      Ensure your output is a valid JSON object.

      ---
      Story Text:
      ${ficText}

      ---
      Author Tags:
      ${authorTags.join(", ")}
      ---
      JSON Output:
    `;

    try {
      const llmResponse = await this.llm.executeLLM(prompt);
      let parsedResponse: LLMOutput;

      // Attempt to parse the LLM's response, handling potential invalid JSON.
      try {
        // Trim whitespace to help JSON.parse, as LLMs can sometimes include extra characters.
        parsedResponse = JSON.parse(llmResponse.trim());
        if (!Array.isArray(parsedResponse.suggestedTags) || !Array.isArray(parsedResponse.tagsToRemove)) {
          throw new Error("Invalid LLM response structure: 'suggestedTags' and 'tagsToRemove' must be arrays.");
        }
      } catch (parseError) {
        console.error("❌ Failed to parse LLM response as JSON:", llmResponse, (parseError as Error).message);
        return { error: `Failed to parse LLM response: ${(parseError as Error).message}` };
      }

      const { suggestedTags, tagsToRemove } = parsedResponse;

      // Filter and refine suggestedTags: unique, not in authorTags, and max 20.
      const uniqueSuggestedTags = Array.from(new Set(suggestedTags));
      const finalSuggestedTags = uniqueSuggestedTags
        .filter(tag => !authorTags.includes(tag))
        .slice(0, 20); // Cap at 20 suggested tags

      // Filter tagsToRemove: ensure they are actually from the provided authorTags.
      const uniqueTagsToRemove = Array.from(new Set(tagsToRemove));
      const finalTagsToRemove = uniqueTagsToRemove
        .filter(tag => authorTags.includes(tag));

      // Update or insert the FicCategory document in MongoDB.
      await this.ficCategories.updateOne(
        { _id: fic }, // Query by the fic ID
        { $set: { suggestedTags: finalSuggestedTags, tagsToRemove: finalTagsToRemove } },
        { upsert: true }, // Create a new document if one does not exist for this fic ID
      );

      return { suggestedTags: finalSuggestedTags, tagsToRemove: finalTagsToRemove };
    } catch (error) {
      console.error("❌ Error during categorization process for fic ID:", fic, (error as Error).message);
      return { error: `Failed to process categorization: ${(error as Error).message}` };
    }
  }

  /**
   * @action viewFicCategory
   * @purpose Retrieves the stored categorization information for a specific fanfiction.
   *
   * @requires The `fic` (ID) must be associated with an existing `FicCategory` document in the `ficCategories` collection.
   * @effects If found, returns the `FicCategory` document. Otherwise, returns an error.
   *
   * @param {object} args
   * @param {Fic} args.fic - The ID of the fanfiction whose category is to be viewed.
   * @returns {Promise<FicCategoryDoc | {error: string}>}
   *          Returns the `FicCategoryDoc` if found, or an error object if not.
   */
  async viewFicCategory({ fic }: { fic: Fic }): Promise<FicCategoryDoc | { error: string }> {
    // Precondition: Check if a document with the given `fic` ID exists.
    const ficCategory = await this.ficCategories.findOne({ _id: fic });

    if (!ficCategory) {
      return { error: `No FicCategory found for fic ID: ${fic}` };
    }

    return ficCategory;
  }

  /**
   * @action deleteFicCategory
   * @purpose Removes the categorization information for a specific fanfiction.
   *
   * @requires The `fic` (ID) must be associated with an existing `FicCategory` document in the `ficCategories` collection.
   * @effects Deletes the `FicCategory` document associated with the `fic` from the `ficCategories` collection.
   *
   * @param {object} args
   * @param {Fic} args.fic - The ID of the fanfiction whose category is to be deleted.
   * @returns {Promise<Empty | {error: string}>}
   *          Returns an empty object `{}` on successful deletion, or an error object.
   */
  async deleteFicCategory({ fic }: { fic: Fic }): Promise<Empty | { error: string }> {
    // Precondition: Verify that the FicCategory exists before attempting deletion.
    const exists = await this.ficCategories.countDocuments({ _id: fic });
    if (exists === 0) {
      return { error: `No FicCategory found for fic ID: ${fic} to delete.` };
    }

    try {
      await this.ficCategories.deleteOne({ _id: fic });
      return {}; // Empty record for successful completion
    } catch (error) {
      console.error("❌ Error deleting FicCategory for fic ID:", fic, (error as Error).message);
      return { error: `Failed to delete FicCategory for fic ID ${fic}: ${(error as Error).message}` };
    }
  }

  /**
   * @action deleteFicCategories
   * @purpose Removes categorization information for multiple fanfictions.
   *
   * @requires All `ficCategories` corresponding to the provided `ficCats` (IDs) must exist within the `ficCategories` collection.
   * @effects Iterates through the provided `ficCats` and performs a deletion for each corresponding `FicCategory` document.
   *
   * @param {object} args
   * @param {Fic[]} args.ficCats - An array of `Fic` IDs whose categories are to be deleted.
   * @returns {Promise<Empty | {error: string}>}
   *          Returns an empty object `{}` on successful deletion of all specified categories, or an error object.
   */
  async deleteFicCategories({ ficCats }: { ficCats: Fic[] }): Promise<Empty | { error: string }> {
    if (ficCats.length === 0) {
      return { error: "No fic IDs provided for bulk deletion." };
    }

    try {
      // Use `deleteMany` for efficiency, targeting all provided IDs.
      const deleteResult = await this.ficCategories.deleteMany({ _id: { $in: ficCats } });

      // While `deleteMany` will only delete existing documents, the "requires" clause implies
      // that we might want to ensure all passed IDs correspond to actual deletions.
      // If `deletedCount` is less than `ficCats.length`, it means some specified IDs did not
      // have an associated FicCategory. This is a partial success or a warning, depending on interpretation.
      if (deleteResult.deletedCount !== ficCats.length) {
        console.warn(`⚠️ Warning: Not all specified FicCategories were found for deletion.
                      Attempted to delete ${ficCats.length} categories, but only ${deleteResult.deletedCount} were found and deleted.`);
      }
      return {};
    } catch (error) {
      console.error("❌ Error deleting multiple FicCategories:", (error as Error).message);
      return { error: `Failed to delete multiple FicCategories: ${(error as Error).message}` };
    }
  }
    private readCsvFileAsString(filePath: string): string {
    try {
        const fullPath = path.resolve(filePath);
        const fileContent = fs.readFileSync(fullPath, { encoding: 'utf-8' });
        return fileContent;
    } catch (error) {
        console.error(`Error reading CSV file: ${error}`);
        throw error;
    }
}
}

```
