---
timestamp: 'Mon Oct 13 2025 15:50:12 GMT-0400 (Eastern Daylight Time)'
content_id: 5a9d5d6023d86cb5f8100234dbf8e6e6b82d67d067ca93e45ccabfc72cb55f16
---

# file: src/concepts/Categorizing/CategorizingConcept.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { ID } from "@utils/types.ts";
// import { freshID } from "@utils/database.ts"; // freshID is used for generating new IDs if needed
import { GeminiLLM, Config as LLMConfig } from "../../../gemini-llm.ts"; // Path to the provided LLM integration
import * as fs from 'node:fs';
import * as path from 'node:path';

// --- Concept Specific Types ---

// Generic type parameter 'Fic' as defined in the concept specification.
// It will be an externally created ID.
type Fic = ID;

/**
 * A Tag, including its name, type, and the reason for its suggestion or removal.
 * This acts as the "Tag" type from the concept state, with 'name', 'type', 'reason' properties.
 */
interface Tag {
  name: string;
  type: string;
  reason: string;
}

/**
 * Represents the structure of input for fic categorization actions.
 * The concept itself doesn't store the full `ficText` or `authorTags`,
 * but these are required for the LLM's operation.
 */
interface FicInput {
  ficId: Fic;
  ficText: string;
  authorTags: { name: string; type: string }[]; // Author tags for LLM, can be simpler
}

/**
 * Represents the document structure stored in the MongoDB `ficCategories` collection.
 * This maps directly to "a set of FicCategories" from the concept state,
 * where `_id` is the 'Fic' identifier, and `suggestedTags` and `tagsToRemove`
 * are arrays of `Tag` objects (acting as the 'Category' type).
 */
interface FicCategoryDoc {
  _id: Fic; // The ID of the fic this categorization applies to
  suggestedTags: Tag[];
  tagsToRemove: Tag[];
}

/**
 * Defines the expected JSON output structure from the LLM.
 * This is crucial for parsing the LLM's response into structured data.
 */
interface LLMOutput {
  suggestedTags: Tag[];
  tagsToRemove: Tag[];
}

// Declare collection prefix, using the concept name to avoid collisions.
const PREFIX = "Categorizing" + ".";

/**
 * **concept** Categorizing [Fic]
 *
 * **purpose** to categorize a text into specific categories (i.e. a story will be categorized into a set of tags).
 * "Categorizing" can also *remove* tags provided by the author if deemed necessary.
 *
 * **principle** A user submits their story and the tags the author has already added to the story.
 * It outputs a list of suggested tags (properly categorized) to add to the story and tells the user if any of their author tags should be removed.
 */
export default class CategorizingConcept {
  // State: MongoDB collection to store the `FicCategoryDoc` documents.
  // This corresponds to "a set of FicCategories" in the concept spec.
  ficCategories: Collection<FicCategoryDoc>;
  private llm: GeminiLLM;

  constructor(private readonly db: Db, llmConfig: LLMConfig) {
    this.ficCategories = this.db.collection(PREFIX + "ficCategories");
    this.llm = new GeminiLLM(llmConfig);
  }

  private getTagsCsvContext(): string {
    const csvFilePath = '../tagsEdited2021.csv';

    return this.readCsvFileAsString(csvFilePath);
  }

  private readCsvFileAsString(filePath: string): string {
    try {
        const fullPath = path.resolve(filePath);
        const fileContent = fs.readFileSync(fullPath, { encoding: 'utf-8' });
        return fileContent;
    } catch (error) {
        console.error(`Error reading CSV file: ${error}`);
        throw error;
    }
  }

  // --- Actions ---

  /**
   * **keywordGenerator** (fic) : (suggestedTags: Category)
   * **tagCleaner** (fic) : (tagsToRemove: Category)
   *
   * This action combines the functionality of `keywordGenerator` and `tagCleaner`
   * into a single LLM call for efficiency and consistency, as suggested.
   * It takes a fic's content and existing author tags, and returns both
   * suggested new tags and a list of author tags that should be removed.
   *
   * **requires** The input object must contain `ficId` (the unique identifier for the fic),
   *              `ficText` (the full text content of the fic), and `authorTags`
   *              (an array of tags already provided by the author).
   * **effects**
   *   1. Uses an LLM to analyze `ficText` and `authorTags`.
   *   2. Generates up to 20 highly relevant `suggestedTags` that are not already present
   *      in the `authorTags`. Each suggested tag includes its `name`, `type`, and a `reason` for suggestion.
   *   3. Identifies `tagsToRemove` from the `authorTags` that are deemed inappropriate,
   *      irrelevant, or misleading based on the `ficText`. Each tag to remove includes
   *      its `name`, `type`, and a `reason` for removal.
   *   4. An entry in the `ficCategories` collection is either created (if one doesn't exist
   *      for `ficId`) or updated to store these `suggestedTags` and `tagsToRemove`.
   *   5. Returns the generated `suggestedTags` and `tagsToRemove`.
   */
  async categorizeFic(
    { ficId, ficText, authorTags }: FicInput,
  ): Promise<{ suggestedTags: Tag[]; tagsToRemove: Tag[] } | { error: string }> {
    if (!ficId || !ficText || authorTags === undefined) {
      return { error: "Fic ID, text, and author tags are required." };
    }

    // Prepare author tags for embedding into the LLM prompt.
    const authorTagStrings = authorTags
      .map((tag) => `${tag.name} (type: ${tag.type})`)
      .join(", ");

    const csvString = this.getTagsCsvContext();

    // Context for the LLM to guide its expertise and output format.
    // This simulates training on the @tagsEdited2021.csv file by instructing the LLM
    // to act as if it's knowledgeable about AO3 tagging conventions.
    const trainingContext = `
You are a helpful AI assistant that returns a list of fanfiction tags for people to tag their fanfictions with, and helps to refine their already-existing tag ideas.

Analyze the fanfiction content and compare it to the user's proposed tags. Based on that:
1. Suggest new tags to add from the official list if they are clearly supported by the story.
2. Suggest tags to remove if the user proposed them but they are not clearly supported by the story.
3. Explain your decisions for each added or removed tag in a reasons section.

CRITICAL RULES:
1. Only suggest to add tags that are present in the official list.
2. Tags must be grounded in the content. Do not guess or infer beyond what is present. Do not rely on the author's proposed tags as evidence.
3. If a section (like tagsToRemove) has no entries, return it as an empty object ({}).
4. Output only the JSON object — no extra commentary, explanations, or markdown.
5. NO DUPLICATION: Do not suggest adding a tag if it is already included in the author's proposed tag list.
6. Do NOT suggest to remove a tag just because it is not standard, recognized, or within the list of recognized tags.
7. DO NOT suggest to remove tags because they are too specific.

For context, / is romantic relationships (and categories) and & is platonic relationships. M/M, F/M, F/F are for romance categories and Gen is for platonic categories.
Users often filter by relationships, so just because 2 characters are proposed tags does not mean that the relationship tag itself should be removed.

For the list of tags generated for the fanfiction each with a type as specified from the list of offical tags, return your response as a JSON object with this exact structure:
{
  "content": {
    "tagsToAdd": [
      {
        "name": "TagName",
        "type": "TagType",
        "reason": "Reason this tag was added."
      }
    ],
    "tagsToRemove": [
      {
        "name": "TagName",
        "type": "TagType",
        "reason": "Reason this tag was removed."
      }
    ]
  }
}

Do NOT return it starting with \`\`\`json and ending in \`\`\`.
Return ONLY the JSON object, no additional text.
    `;

    const prompt = `
      ${trainingContext}

      Here is a fanfiction story and its author-provided tags:

      Fic ID: ${ficId}
      Fic Text:
      ${ficText}
      Author Tags: ${
        authorTagStrings.length > 0 ? authorTagStrings : "None provided by author."
      }
    `;

    try {
      const llmResponseText = await this.llm.executeLLM(prompt);
      const jsonMatch = llmResponseText.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
          throw new Error('No JSON found in response');
      }
      const parsedResponse = JSON.parse(jsonMatch[0]);
      // const parsedResponse: LLMOutput = JSON.parse(llmResponseText);

      const suggestedTags = parsedResponse.suggestedTags || [];
      const tagsToRemove = parsedResponse.tagsToRemove || [];

      // Filter suggested tags to ensure no duplicates with author's existing tags
      const existingAuthorTagNames = new Set(
        authorTags.map((t) => t.name.toLowerCase()),
      );
      const filteredSuggestedTags = suggestedTags.filter(
        (st: Tag) => !existingAuthorTagNames.has(st.name.toLowerCase()),
      );

      // Store/update the categorization results in the database
      await this.ficCategories.updateOne(
        { _id: ficId }, // Find the document by fic ID
        {
          $set: {
            suggestedTags: filteredSuggestedTags.slice(0, 20), // Ensure max 20 suggested tags
            tagsToRemove: tagsToRemove,
          },
        },
        { upsert: true }, // Create the document if it doesn't exist
      );

      return {
        suggestedTags: filteredSuggestedTags.slice(0, 20),
        tagsToRemove: tagsToRemove,
      };
    } catch (error) {
      console.error(
        `❌ Error in categorizeFic for fic ID '${ficId}':`,
        (error as Error).message,
      );
      // Return a structured error response as per guidelines
      return {
        error: `Failed to categorize fic: ${(error as Error).message}`,
      };
    }
  }

  /**
   * **viewFicCategory** (fic) : (ficCategory)
   *
   * Retrieves the categorization data (suggested tags and tags to remove) for a specific fic.
   *
   * **requires** The `ficId` must correspond to an existing entry in the `ficCategories` collection.
   * **effects** If an entry exists, returns the `FicCategoryDoc` associated with the given `ficId`.
   *            Otherwise, returns an error indicating the ficCategory was not found.
   */
  async viewFicCategory(
    { ficId }: { ficId: Fic },
  ): Promise<FicCategoryDoc | { error: string }> {
    if (!ficId) {
      return { error: "Fic ID is required." };
    }

    const ficCategory = await this.ficCategories.findOne({ _id: ficId });

    if (!ficCategory) {
      return { error: `FicCategory for fic ID '${ficId}' not found.` };
    }

    return ficCategory;
  }

  /**
   * **deleteFicCategory** (fic) : (ficCategory)
   *
   * Removes the categorization data for a single fic from the system.
   *
   * **requires** The `ficId` must correspond to an existing entry in the `ficCategories` collection.
   * **effects** If found, the `FicCategoryDoc` associated with `ficId` is removed from the `ficCategories` collection.
   *            Returns the deleted `FicCategoryDoc` or an error if not found/failed.
   */
  async deleteFicCategory(
    { ficId }: { ficId: Fic },
  ): Promise<FicCategoryDoc | { error: string }> {
    if (!ficId) {
      return { error: "Fic ID is required." };
    }

    // Find the document first to return it upon successful deletion
    const existingCategory = await this.ficCategories.findOne({ _id: ficId });
    if (!existingCategory) {
      return { error: `FicCategory for fic ID '${ficId}' not found.` };
    }

    const result = await this.ficCategories.deleteOne({ _id: ficId });

    if (result.deletedCount === 0) {
      // This should ideally not happen if existingCategory was found, but good for robustness
      return { error: `Failed to delete FicCategory for fic ID '${ficId}'.` };
    }

    return existingCategory; // Return the document that was just deleted
  }

  /**
   * **deleteFicCategories** (ficCats: set of ficCategories)
   *
   * Removes categorization data for multiple fics from the system.
   *
   * **requires** All `ficIds` in the input list should correspond to existing entries
   *              in the `ficCategories` collection for a successful operation.
   * **effects** Attempts to remove all `FicCategoryDoc` entries whose `_id` is present
   *            in the `ficIds` list. Returns the count of successfully deleted categories.
   *            Returns an error if the input list is empty or no categories were deleted.
   */
  async deleteFicCategories(
    { ficIds }: { ficIds: Fic[] },
  ): Promise<{ deletedCount: number } | { error: string }> {
    if (!ficIds || ficIds.length === 0) {
      return { error: "Fic IDs list cannot be empty." };
    }

    const result = await this.ficCategories.deleteMany({ _id: { $in: ficIds } });

    if (result.deletedCount === 0) {
      return { error: `No FicCategories found or deleted for the provided IDs.` };
    }

    return { deletedCount: result.deletedCount };
  }

  /**
   * **_getAllFicCategories** () : (ficCategories: FicCategoryDoc[])
   *
   * A query to retrieve all stored fic categorization entries.
   * Queries typically start with an underscore `_`.
   *
   * **effects** Returns an array containing all `FicCategoryDoc` documents currently in the state.
   */
  _getAllFicCategories(): Promise<FicCategoryDoc[]> {
    return this.ficCategories.find({}).toArray();
  }
}

```
