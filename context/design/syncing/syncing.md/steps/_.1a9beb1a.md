---
timestamp: 'Mon Nov 03 2025 21:34:00 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251103_213400.a0fc43b6.md]]'
content_id: 1a9beb1a7458aba1e6b61cc276b6e1a1b782af81753c1be517242a94713e824e
---

# Architecture Overview

The concept design approach structures its architecture entirely around two fundamental building blocks:

1. **Concepts**: Self-contained, modular increments of functionality (e.g., `Sessioning`, `Posting`, `Commenting`).
2. **Synchronizations**: The rules that orchestrate interactions *between* concepts (e.g., "when a post is deleted, delete all its comments").

## Directory Structure

> **Important:** You should only need to add code within the `src/concepts` and `src/syncs` directories.

```
context/
design/
src/
├── concepts/       <-- YOUR CONCEPTS HERE
│   ├── Sessioning/
│   │   └── SessioningConcept.ts
│   ├── Posting/
│   │   └── PostingConcept.ts
│   └── ...
├── syncs/          <-- YOUR SYNCHRONIZATIONS HERE
│   ├── auth.sync.ts
│   └── posts.sync.ts
│
├── engine/         <-- Framework-provided (ignore)
├── utils/          <-- Framework-provided (ignore)
└── main.ts         <-- Entry-point (can configure logging)
```

## The `Requesting` Concept: Application Entry-point

The architecture will automatically spin up an HTTP server for your application. However, you might wonder how exactly an external HTTP request triggers your logic. This is handled by the provided concept called `Requesting`.

When an HTTP request hits the server, the Concept Engine automatically translates it into a `Requesting.request` action. You don't implement this concept; you just use its actions as triggers in your synchronizations.

> **Important:** by default, `Requesting` also includes *passthrough routes* that automatically generate routes for direct access to concept actions and queries. Please read the [Requesting README](../../src/concepts/Requesting/README.md) for more details.

For example, an incoming request like `POST /api/posts/create` with a JSON body `{ "title": "My First Post", "content": "Hello world!", "session": "s123" }` is automatically converted into an action that looks like this:

`Requesting.request({ path: "/posts/create", title: "My First Post", content: "Hello world!", session: "s123" })`

You can then write a [synchronization](implementing-synchronizations.md) to "catch" this action and do something useful with it:

```typescript
// in src/syncs/posts.sync.ts
const CreatePostOnRequest: Sync = ({ title, content, session, user }) => ({
    when: actions(
        // Catches the request from the engine
        [Requesting.request, { path: "/posts/create", title, content, session }, {}],
    ),
    where: (frames) => {
        // Authorizes the request by checking the session
        return frames
            .query(Sessioning.getUser, { session }, { user });
    },
    then: actions(
        // If we got here, we found a logged in user
        [Posting.create, { title, content, author: user }],
    ),
});
```

By creating the `Sessioning` and `Posting` concepts and including this synchronization, you created an operational and authenticated API endpoint for creating posts. The `Requesting` concept encapsulates the concerns surrounding HTTP requests, and therefore abstracted away the need for specifying a HTTP server, controllers, middleware, etc.

## Initialization

1. Configure any environment variables you need in `.env`
2. Build command: `deno run build` to scan and automatically generate imports for concepts/syncs.
3. Start command: `deno run start` to begin your server.

## My original spec already had an AI augmentation

**concept** Categorizing \[Fic]

**purpose** to categorize a text into specific categories (i.e. a story will be categorized into a set of tags). "Categorizing" can also *remove* tags provided by the author if deemed necessary.

**principle** A user submits their story and the tags the author has already added to the story. It outputs a list of suggested tags (properly categorized) to add to the story and tells the user if any of their author tags should be removed.

**state**

     a set of FicCategories with

         a Fic

         a suggestedTags Category

         a tagsToRemove Category

     a Category with

         a set of Tags

     a Tag with

         a Name string

         a Type string

         a Reason string

**actions**

     **categorizeFic** (fic) : (fic)

         **effect** using an LLM, the LLM will examine the fic's ficText's contents, and associates the top 20 most relevant tags (WITHOUT suggesting tags already included in the fic's authorTags) (the tags having a name, type, and reason for why they are being suggested) to the content in a suggestedTags Category to the Fic and (if there is not an FicCategory already associated with fic) creates a new FicCategory out of those and adds the FicCategory to the set of FicCategories, or (if there is a FicCategory associated with the fic) adds the suggestedTags to said ficCategory. Finally, it returns the suggestedTags.
Type of tags includes: ArchiveWarning, fandom, character, relationship, freeform, rating, category. using an LLM, the LLM will examine the fic's ficText's contents, then compare it to each authorTag in the foc's set of authorTags. If an authorTag seems inappropriate for the fic, it will add it to a Category of tags to remove (including its name, type, and reason for removal). At the very end, if there is already a ficCategory associated with fic, it will add the tagsToRemove Category to the ficCategory. If not, it'll create a new ficCategory and associate the fic and tagsToRemovewith it, and add it to the set of ficCategories. Finally, it returns the tagsToRemove.

     **\_viewFicCategory** (fic) : (ficCategory)

         **requires** the fic to be associated with a ficCategory in the set of ficCategories

         **effect** returns the ficCategory.

     **deleteFicCategory** (fic) : (ficCategory)

         **requires** the fic to be associated with a ficCategory in the set of ficCategories

         **effect** removes the ficCategory associated with the fic from the set of FicCategories.

     **deleteFicCategories** (deletedCount: number)

         **requires** all ficCategories to exist within the set of FicCategories.

         **effect** runs deleteFicCategory on all ficCategories in the set of ficCategories. Returns number of ficCats deleted
